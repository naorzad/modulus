def calculate_2d_normals(points, n_neighbors=4, epsilon=1e-6):
    """Calculate normals for a 2D point cloud with increased neighbor count and robust normalization."""
    nbrs = NearestNeighbors(n_neighbors=n_neighbors, algorithm='ball_tree').fit(points)
    _, indices = nbrs.kneighbors(points)
    
    normals = np.zeros(points.shape, dtype=np.float32)
    
    for i, neighbors in enumerate(indices):
        p0 = points[i]
        slopes = []
        for j in range(1, n_neighbors):
            p1 = points[neighbors[j]]
            slope = (p1[1] - p0[1]) / (p1[0] - p0[0] + epsilon) if p1[0] != p0[0] else np.inf
            slopes.append(slope)
        
        # Calculate average slope, ignoring infinities
        valid_slopes = [s for s in slopes if not np.isinf(s)]
        if valid_slopes:
            avg_slope = np.mean(valid_slopes)
        else:
            avg_slope = 0
        
        # Transform to get the normal
        if avg_slope != 0:
            normal_slope = -1 / avg_slope
            normal = np.array([1, normal_slope], dtype=np.float32)
        else:
            normal = np.array([0, 1], dtype=np.float32)
        
        # Normalize the normal vector if it's not zero
        norm = np.linalg.norm(normal)
        if norm != 0:
            normal /= (norm + epsilon)  # Add epsilon to avoid division by zero or very small values
        
        normals[i] = normal
    normals = ensure_normals_point_outward(points, normals)
    visualize_normals(points, normals)
    return normals